var searchIndex = new Map(JSON.parse('[\
["crater",{"doc":"Very Generic Data Structures","t":"PRKKRPPGNNMCMCNHNMCMMMCMMMNNNNFFNNNNNNNNNNONNNNNNNNNNNNNNNNNNONNNNNNNNNNNFKFNNNNMNNNNNMNNNNNNNNNNNNNNNTTFFFPGFPPNNNNNNNNNNONNNNNNNNNNNNNNNONNNNNNNNNNNNNNNONNNNNNNNNONNNNNNNNNNNNNNNNNNNNNNFNNNNNNNNNNNNNNNNNNNNNN","n":["Continue","Distance","KdPoint","KdRegion","Point","SkipChildren","Stop","WalkDecision","borrow","borrow_mut","cmp","cuboid","extend","fheap","from","get_bounds","into","is_superset","kdtree","max_sqdist","might_overlap","min_sqdist","mmheap","single_point","split","sqdist","try_from","try_into","type_id","vzip","CuPoint","CuRegion","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","default","end","eq","extend","extract","fmt","fmt","from","from","from","into","into","is_superset","make","max_sqdist","might_overlap","min_sqdist","single_point","split","sqdist","start","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","view","vzip","vzip","FibHeap","Node","RawNode","borrow","borrow","borrow_mut","borrow_mut","cmp","decrease_key","default","fmt","from","from","get_raw","into","into","new","peek_min","pop_min","push","remove","try_from","try_from","try_into","try_into","type_id","type_id","vzip","vzip","ALL_KEEP_TIES","ALL_NO_TIES","Iter","IterMut","KdTree","None","QueryBound","QueryOptions","Region","SqDist","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","bounds","contains","contains_point","fmt","from","from","from","from","from","from","from_iter","get","get_mut","get_point_value","index","index_mut","inner_bound","into","into","into","into","into","into_iter","into_iter","into_iter","into_iter","into_iter","into_points","into_values","iter_points","iter_values","k_closest","keep_ties","launder_idx_mut","launder_idx_point","launder_point_ref","launder_value_ref","len","might_overlap","mut_values","next","next","outer_bound","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","vzip","vzip","vzip","vzip","vzip","walk","walk_mut","MmHeap","borrow","borrow_mut","extend_by","from","ify_by","into","into","into_iter","len","make","new","peek_max_by","peek_min","pop_max_by","pop_min_by","push_by","pushpop_max_by","pushpop_min_by","try_from","try_into","type_id","vzip"],"q":[[0,"crater"],[30,"crater::cuboid"],[73,"crater::fheap"],[102,"crater::kdtree"],[187,"crater::mmheap"],[210,"core::cmp"],[211,"core::cmp"],[212,"num_traits::identities"],[213,"core::option"],[214,"core::iter::traits::collect"],[215,"core::result"],[216,"core::any"],[217,"num_traits"],[218,"core::cmp"],[219,"core::fmt"],[220,"core::iter::traits::iterator"],[221,"core::ops::function"],[222,"core::ops::function"]],"d":["","The type used by sqdist and related KdRegion functions to …","A point in the tree.  Types implementing this can contain …","A region in the tree, or in space in general.  A type …","","","","Tree traversal control flow, similar to Rust’s builtin …","","","Compare two points in some layer of the tree.  This …","","Given a region and a point possibly not in the region, …","A fibonacci heap is a type of data structure optimized for …","Returns the argument unchanged.","Get the bounding box of a set of points.  For …","Calls <code>U::from(self)</code>.","Return true if this region is DEFINITELY a superset of …","","Return the maximal squared distance any point in this …","Return true if this region and another region might …","Return the minimal squared distance any point in this …","","Create a region consisting of a single point.  For cuboid …","Given a point <code>p</code> in this region <code>A</code> and a layer <code>l</code>, split <code>A</code> …","The squared distance is more computationally convenient …","","","","","Represents a point in N-dimensional Euclidean space whose …","Represents an axis aligned cuboid region in N-dimensional …","","","","","","","","","","","","","","consume the point to mutably access the buffer","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","make a point with a given value","","","","","","","","","","","","","","","","get readonly access to the buffer","","","A fibonacci heap is a type of data structure optimized for …","Any struct can be used as the fib heap element simply by …","The intrusive struct itself that should be embedded in any …","","","","","Comparison function for nodes, can just wrap Ord impl if …","Called immediately AFTER a node’s key is decreased, to …","","","Returns the argument unchanged.","Returns the argument unchanged.","Get a reference to the embedded raw node.  This is used …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Create a new fibonacci heap whose backing storage will …","Get the minimal element if it exists, returning a …","Get and remove the minimal element if it exists, returning …","Add a node to the heap.  This is unsafe because the node …","Remove a node from the heap by reference.  Since the heap …","","","","","","","","","Default <code>QueryOptions</code> to have the included region be the …","Default <code>QueryOptions</code> to have the included region be the …","","","A KD tree represents a collection of points in space, with …","","Represents an inner / outer limit for a query within the …","Fine grained control over a query within the tree (…","","","","","","","","","","","","","","Returns true if the included region contains the point <code>pt</code>, …","Return true if the tree contains some point or false …","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","Returns the argument unchanged.","","Return a reference to the value for some point in the …","Return a mutable reference to the value for some point in …","Return a reference to a point in the tree and the …","","","Points within this bound will be EXCLUDED from the query …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","Consuming iterator over only points, which are moved out …","Consuming iterator over only values, which are moved out …","Borrowing iterator over only references to points. The …","Borrowing iterator over only references to values. The …","Return the k points in the tree which are the closest to a …","If false, if multiple points are tied for being the kth …","Convert an internal index into a mutable reference to a …","Convert an internal index into a reference to a point in …","Convert a const reference to a point in the tree into an …","Convert a const reference to a value in the tree into an …","Get the number of points in the kdtree","Returns true if the included region might overlap with …","Mutable borrowing iterator over only references to values. …","","","Points outside this bound will be EXCLUDED from the query …","","","","","","","","","","","","","","","","","","","","","Iterate over all point, value pairs in the tree in depth …","Iterate over all point, value pairs in the tree in depth …","An implicit binary heap that can efficiently find the min …","","","Add all elements yielded from an iterator This is the same …","Returns the argument unchanged.","Reorder the heap according to a new comparison function. It…","","Calls <code>U::from(self)</code>.","","Get the number of elements in the heap","Create an MmHeap out of a vector and immediately heapify …","Create an empty MmHeap","Get the maximum element without removing it","Get the minimum element without removing it","Get the maximal element and remove it","Get the minimal element and remove it","Insert an element into the heap Elements that compare …","Insert a new element and remove the max element in the …","Insert a new element and remove the min element in the …","","","",""],"i":[37,2,0,0,9,37,37,0,37,37,2,0,9,0,37,0,37,9,0,9,9,9,0,9,9,2,37,37,37,37,0,0,18,20,18,20,18,20,18,20,18,18,20,18,20,18,18,20,18,18,20,18,20,20,18,20,20,20,20,20,18,20,18,20,18,20,18,20,18,20,18,18,20,0,0,0,27,29,27,29,26,27,29,29,27,29,26,27,29,27,27,27,27,27,27,29,27,29,27,29,27,29,30,30,0,0,0,41,0,0,41,41,41,30,34,35,31,41,30,34,35,31,31,30,31,31,41,30,34,35,31,31,31,31,31,31,31,31,30,41,30,34,35,31,34,35,31,31,31,31,31,31,31,31,30,31,31,31,31,31,30,31,34,35,30,41,30,34,35,31,41,30,34,35,31,41,30,34,35,31,41,30,34,35,31,31,31,0,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33],"f":"````````{ce{}{}}0{{{d{}{{b{c}}}}{d{}{{b{c}}}}f}h{jln}}`{{{Ab{}{{A`{c}}}}c}Add}`{cc{}}{c{{Af{e}}}{{Aj{}{{Ah{}}}}}Ab}4{{{Ab{}{{A`{c}}}}{Ab{}{{A`{c}}}}}Ald}`{{{Ab{}{{A`{c}}}}c}Afd}1{{{Ab{}{{A`{c}}}}c}{}d}`{c{{Ab{}{{A`{c}}}}}d}{{{Ab{}{{A`{c}}}}cf}{{An{{Ab{}{{A`{c}}}}{Ab{}{{A`{c}}}}}}}d}{{{d{}{{b{c}}}}{d{}{{b{c}}}}}c{jln}}{c{{B`{e}}}{}{}}0{cBb{}}<``<<<<{{{Bd{c}}}{{Bd{c}}}{jlBfl}}{{{Bh{c}}}{{Bh{c}}}{jlBfl}}{{ce}Ad{}{}}0{{{Bd{c}}{Bd{c}}f}h{jlBf}}{{}{{Bd{c}}}{jlBf}}`{{{Bd{c}}{Bd{c}}}Al{jlBfBj}}{{{Bh{c}}e}Ad{jlBf}{}}{{{Bd{c}}}{{Bl{c}}}{jlBf}}{{{Bd{c}}Bn}C`{jlBfCb}}{{{Bh{c}}Bn}C`{jlBfCb}}{{{Bl{c}}}{{Bd{c}}}{jlBf}}{cc{}}0{ce{}{}}0{{{Bh{c}}{Bh{c}}}Al{jlBf}}3{{{Bh{c}}e}{{Af{c}}}{jlBf}{}}1{{{Bh{c}}e}c{jlBf}{}}{c{{Bh{e}}}{}{jlBf}}{{{Bh{c}}ef}{{An{{Bh{c}}{Bh{c}}}}}{jlBf}{}}{{{Bd{c}}{Bd{c}}}e{jlBf}{}}`66{c{{B`{e}}}{}{}}000{cBb{}}0=88```8888{{CdCd}h}{{{Cf{ce}}c}Ad{CdCh}{}}{{}{{Cj{c}}}{CdCh}}{{{Cj{c}}Bn}C`{CbCdCh}}=={Cd{{Cj{Cd}}}}=={c{{Cf{ec}}}{}{CdCh}}{{{Cf{ce}}}{{Af{c}}}{CdCh}{}}055888877??``````````??????????`{{{Cl{c}}}AlAb}{{{Cn{ce}}}AlAb{}}{{{Cn{ce}}Bn}C`{CbAb}Cb}{cc{}}000{{{Bl{{An{c}}}}}{{Cn{ec}}}{}Ab}1{e{{Cn{gc}}}{}{{Aj{}{{Ah{{An{c}}}}}}}Ab}{{{Cn{ce}}}{{Af{e}}}Ab{}}0{{{Cn{ce}}}{{Af{{An{e}}}}}Ab{}}{{{Cn{ce}}}eAb{}}{{{Cn{ce}}}gAb{}{}}`{ce{}{}}000000111{{{Cn{ce}}}{{`{{D`{}{{Ah{}}}}}}}Ab{}}{{{Cn{ce}}}{{`{{D`{}{{Ah{e}}}}}}}Ab{}}10{{{Cn{ce}}f{Cl{c}}}{{Db{{An{e}}}}}Ab{}}`{{{Cn{ce}}f}eAb{}}{{{Cn{ce}}f}{}Ab{}}{{{Cn{ce}}}fAb{}}{{{Cn{ce}}e}fAb{}}1{{{Cl{c}}Afc}AlAb}6{{{Dd{ce}}}{{Af{g}}}d{}{}}{{{Df{ce}}}{{Af{g}}}d{}{}}`{c{{B`{e}}}{}{}}000000000{cBb{}}0000<<<<<{{{Cn{ce}}g}AdAb{}{{Dl{ce}{{Dh{Dj}}}}}}0`=={{{Db{c}}eg}Ad{}{{Aj{}{{Ah{c}}}}}{{Dn{cc}{{Dh{h}}}}}}{cc{}}{{{Db{c}}e}Ad{}{{Dn{cc}{{Dh{h}}}}}}{{{Db{c}}}{{E`{c}}}{}}{ce{}{}}{{{Db{c}}}e{}{}}{{{Db{c}}}f{}}{{{E`{c}}e}{{Db{c}}}{}{{Dn{cc}{{Dh{h}}}}}}{{}{{Db{c}}}{}}{{{Db{c}}e}{{Af{c}}}{}{{Dn{cc}{{Dh{h}}}}}}{{{Db{c}}}{{Af{c}}}{}}11{{{Db{c}}ce}Ad{}{{Dn{cc}{{Dh{h}}}}}}{{{Db{c}}ce}c{}{{Dn{cc}{{Dh{h}}}}}}0??>8","c":[],"p":[[17,"Distance"],[10,"KdPoint",0],[1,"usize"],[6,"Ordering",210],[10,"Ord",210],[10,"Clone",211],[10,"Zero",212],[17,"Point"],[10,"KdRegion",0],[1,"unit"],[6,"Option",213],[17,"Item"],[10,"IntoIterator",214],[1,"bool"],[1,"tuple"],[6,"Result",215],[5,"TypeId",216],[5,"CuPoint",30],[10,"NumRef",217],[5,"CuRegion",30],[10,"PartialEq",210],[1,"array"],[5,"Formatter",218],[8,"Result",218],[10,"Debug",218],[10,"Node",73],[5,"FibHeap",73],[10,"Sized",219],[5,"RawNode",73],[5,"QueryOptions",102],[5,"KdTree",102],[10,"Iterator",220],[5,"MmHeap",187],[5,"Iter",102],[5,"IterMut",102],[17,"Output"],[6,"WalkDecision",0],[10,"FnMut",221],[10,"Fn",221],[5,"Vec",222],[6,"QueryBound",102]],"b":[[146,"impl-IntoIterator-for-KdTree%3CR,+V%3E"],[147,"impl-IntoIterator-for-%26KdTree%3CR,+V%3E"],[148,"impl-IntoIterator-for-%26mut+KdTree%3CR,+V%3E"]]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
