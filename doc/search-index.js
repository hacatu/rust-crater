var searchIndex = new Map(JSON.parse('[\
["crater",{"doc":"Very Generic Data Structures","t":"PRKKRPPGNNMCMNHNCMCMMMNNNNFFNNNNNNNNNONNNNNNNNNNNNNONNNNNNNNNNNFNNONNNNNNNNNNFNNNNNNNNNNNNNNNNNNNNN","n":["Continue","Distance","KdPoint","KdRegion","Point","SkipChildren","Stop","WalkDecision","borrow","borrow_mut","cmp","cuboid","extend","from","get_bounds","into","kdtree","min_sqdist","mmheap","single_point","split","sqdist","try_from","try_into","type_id","vzip","CuPoint","CuRegion","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","end","extend","extract","fmt","fmt","from","from","from","into","into","min_sqdist","single_point","split","sqdist","start","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","view","vzip","vzip","KdTree","borrow","borrow_mut","bounds","from","into","into_iter","k_closest","make","try_from","try_into","type_id","vzip","walk","MmHeap","borrow","borrow_mut","from","ify_by","into","into","into_iter","len","make","new","peek_max_by","peek_min","pop_max_by","pop_min_by","push_by","pushpop_max_by","pushpop_min_by","try_from","try_into","type_id","vzip"],"q":[[0,"crater"],[26,"crater::cuboid"],[63,"crater::kdtree"],[77,"crater::mmheap"],[99,"core::cmp"],[100,"core::cmp"],[101,"core::iter::traits::collect"],[102,"core::result"],[103,"core::any"],[104,"core::clone"],[105,"num_traits"],[106,"core::fmt"],[107,"core::fmt"],[108,"core::ops::function"],[109,"core::ops::function"]],"d":["","","A point in the tree.  Types implementing this can contain …","A region in the tree, or in space in general.  A type …","","","","Tree traversal control flow, similar to Rust’s builtin …","","","Compare two points in some layer of the tree.  This …","","Given a region and a point possibly not in the region, …","Returns the argument unchanged.","Get the bounding box of a set of points.  For CuRegion and …","Calls <code>U::from(self)</code>.","","Return the minimal squared distance any point in this …","","Create a region consisting of a single point.  For cuboid …","Given a point p in this region A and a layer l, split A …","The squared distance is more computationally convenient …","","","","","Represents a point in N-dimensional Euclidean space whose …","Represents an axis aligned cuboid region in N-dimensional …","","","","","","","","","","","","consume the point to mutably access the buffer","","","Returns the argument unchanged.","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","get readonly access to the buffer","","","A KD tree represents a collection of points in space, with …","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","Return the k points in the tree which are the closest to a …","Construct a KD tree out of a vector of points, moving the …","","","","","Iterate over all points in the tree in depth first order, …","An implicit binary heap that can efficiently find the min …","","","Returns the argument unchanged.","Reorder the heap according to a new comparison function. It…","Calls <code>U::from(self)</code>.","","","Get the number of elements in the heap","Create an MmHeap out of a vector and immediately heapify …","Create an empty MmHeap","Get the maximum element without removing it","Get the minimum element without removing it","Get the maximal element and remove it","Get the minimal element and remove it","Insert an element into the heap Elements that compare …","Insert a new element and remove the max element in the …","Insert a new element and remove the min element in the …","","","",""],"i":[26,2,0,0,7,26,26,0,26,26,2,0,7,26,0,26,0,7,0,7,7,2,26,26,26,26,0,0,15,18,15,18,15,18,15,18,15,18,18,15,15,18,15,15,18,15,18,18,18,18,15,18,15,18,15,18,15,18,15,18,15,15,18,0,23,23,23,23,23,23,23,23,23,23,23,23,23,0,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],"f":"````````{ce{}{}}0{{{d{}{{b{c}}}}{d{}{{b{c}}}}f}hj}`{{{n{}{{l{c}}}}c}A`d}{cc{}}{c{{Ab{e}}}{{Af{}{{Ad{}}}}}n}4`{{{n{}{{l{c}}}}c}{}d}`{c{{n{}{{l{c}}}}}d}{{{n{}{{l{c}}}}cf}{{Ah{{n{}{{l{c}}}}{n{}{{l{c}}}}}}}d}{{{d{}{{b{c}}}}{d{}{{b{c}}}}}cj}{c{{Aj{e}}}{}{}}0{cAl{}}:``::::{{{An{c}}}{{An{c}}}{B`jB`Bb}}{{{Bd{c}}}{{Bd{c}}}{B`jB`Bb}}{{ce}A`{}{}}0{{{An{c}}{An{c}}f}h{jB`Bb}}`{{{Bd{c}}e}A`{jB`Bb}{}}{{{An{c}}}{{Bf{c}}}{jB`Bb}}{{{An{c}}Bh}Bj{BljB`Bb}}{{{Bd{c}}Bh}Bj{BljB`Bb}}?{{{Bf{c}}}{{An{c}}}{jB`Bb}}{cc{}}{ce{}{}}0{{{Bd{c}}e}c{jB`Bb}{}}{c{{Bd{e}}}{}{jB`Bb}}{{{Bd{c}}ef}{{Ah{{Bd{c}}{Bd{c}}}}}{jB`Bb}{}}{{{An{c}}{An{c}}}e{jB`Bb}{}}`44{c{{Aj{e}}}{}{}}000{cAl{}}0;66`66`76{{{Bn{c}}}en{}}{{{Bn{c}}f}C`n}{C`{{Bn{c}}}n}4439{{{Bn{c}}e}A`n{{Cf{c}{{Cb{Cd}}}}}}`::;{{{Ch{c}}e}A`{}{{Cj{cc}{{Cb{h}}}}}};{{{Ch{c}}}{{C`{c}}}{}}{{{Ch{c}}}e{}{}}{{{Ch{c}}}f{}}{{{C`{c}}e}{{Ch{c}}}{}{{Cj{cc}{{Cb{h}}}}}}{{}{{Ch{c}}}{}}{{{Ch{c}}e}{{Ab{c}}}{}{{Cj{cc}{{Cb{h}}}}}}{{{Ch{c}}}{{Ab{c}}}{}}11{{{Ch{c}}ce}A`{}{{Cj{cc}{{Cb{h}}}}}}{{{Ch{c}}ce}c{}{{Cj{cc}{{Cb{h}}}}}}0??>{ce{}{}}","c":[],"p":[[17,"Distance"],[10,"KdPoint",0],[1,"usize"],[6,"Ordering",99],[10,"Ord",99],[17,"Point"],[10,"KdRegion",0],[1,"unit"],[6,"Option",100],[17,"Item"],[10,"IntoIterator",101],[1,"tuple"],[6,"Result",102],[5,"TypeId",103],[5,"CuPoint",26],[10,"Clone",104],[10,"NumRef",105],[5,"CuRegion",26],[1,"array"],[5,"Formatter",106],[8,"Result",106],[10,"Debug",106],[5,"KdTree",63],[5,"Vec",107],[17,"Output"],[6,"WalkDecision",0],[10,"FnMut",108],[5,"MmHeap",77],[10,"Fn",108]],"b":[]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
